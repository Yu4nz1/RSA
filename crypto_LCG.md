

PRNG学习记录
## 随机数安全

随机数安全问题主要是两种

1.开发者没有使用随机数。这里，sb才不会用随机数，当然也可能是开发者没有脑子不知道要用随机数。

2.开发者使用了弱伪随机数，导致随机数生成可以被预测。例如有些开发使用时间戳作为随机数，就很容易被预测；另外，如果seed即种子泄露，那么就相当于随机数已经泄露了，除了种子外还有一个随机数池，如果随机数池不足，那么意味着攻击者可以暴力破解。

## PRNG

我们知道PRNG是伪随机数生成器，其中心的是确定的，如果我们知道其内部的完整状态，就可以对其进行预测。那么此时如果PRNG用于加密密钥或者生成签名证书时，就会存在完全问题。



PRNG：将固定值（seed）传入，并产生使用确定性的算法的输出位序列，种子是由  `TPNG` 生成。

PRF：用于产生一定长度固定长度的伪随机字符串，如对称加密密钥和随机数。

PRNG一般有：

1.线性同余法(例如c语言的rand库和java的java.util,Random类)

2.单向散列函数法

3.密码法

4.ANSI X9.17

### 平方取中法

冯诺依曼提出

基本思想是从一个随机数种子开始，对其平方，然后取中间值，然后重复对得到的数取平方并取中间值，即

1.选择m位数`N(i) `作为种子seed

2.取其平方数，`N(i)^2`

3.`N(i)^2`不足`2m`位，前面补0，选择中间m个位的数，将其作为N(i+1)

（例子：65537 —> 429**50983**69）

4.重复2、3

```python
#random随机数生成（迭代取中）
import datetime
import math
import numpy as np

time=datetime.datetime.now()#时间戳
a=np.arange(100)
a0=str(time)[-6:] #取时间为随机数种子 存在安全漏洞，容易被预测
a1=str(int(a0)**2) #取seed的平方
for i in range(100): #产生随机的100位数，放在a[i]数组,即a[i]数组为随机数序列
    while(len(a1)!=len(a0)*2):#a1不足2m位，前面补0
        a1='0'+a1
    a2=a1[3:9] #取中间m位数
    j=0
    while(a2[j]=='0'): #若取出数字位数减少时，后面补0，将其恢复成m位的数，例如002756，改成275600
        a2=a2+'0'
        j=j+1
    a[i]=int(a2) #重复前面步骤
    a0=a2 
    a1=str(int(a2)**2)
print(a)
a=a/a.max()
print(a)    


#输出结果
[895982 783744 254657 850187 817934 160280 256896 995554 127766 324150
 732220 361461 654054 786634 793049 926716 802544 768710 909150 553722
 608053 728450 639402 834917 863960 464268 544775 779800 880400 751041
 625830 916631 212390 109512 992878 806722 800385 616148 638357 499659
 659116 433901 270077 941585 582312 872650 615180 446432 301530 920340
 257150 661261 266110 814532 462379 794339 974446 545006 315400 994771
 569342 150312 593697 476127 696920 697486 486720 896358 457664 456336
 242544 827591 906863 400500 400250 200062 248030 615188 456275 186875
 922265 572730 196520 386201 151212 865068 342644 404910 952108 509643
 735987 676864 144874 988475 828250 859980 565600 903360 592890 515185]
[0.89998333 0.78724409 0.25579426 0.85398381 0.82158677 0.16099579
 0.25804326 1.         0.12833658 0.32559761 0.73548999 0.36307523
 0.65697491 0.79014699 0.79659064 0.93085458 0.80612805 0.77214295
 0.91321013 0.55619484 0.61076848 0.73170315 0.64225748 0.83864562
 0.86781832 0.46634135 0.54720789 0.78328247 0.88433174 0.75439504
 0.62862487 0.92072454 0.2133385  0.11000106 0.99731205 0.8103247
 0.8039594  0.61889963 0.64120781 0.5018904  0.66205952 0.43583874
 0.27128312 0.94578998 0.58491252 0.87654713 0.6179273  0.4484257
 0.30287659 0.92445011 0.25829839 0.6642141  0.26729841 0.81816958
 0.46444392 0.7978864  0.97879773 0.54743992 0.31680853 0.9992135
 0.5718846  0.15098327 0.59634836 0.47825331 0.70003234 0.70060087
 0.48889362 0.90036101 0.45970786 0.45837393 0.24362717 0.8312869
 0.91091292 0.40228858 0.40203746 0.20095545 0.24913767 0.61793534
 0.45831266 0.18770956 0.9263837  0.57528773 0.19739763 0.38792572
 0.15188729 0.86893127 0.3441742  0.40671827 0.95635998 0.51191899
 0.73927381 0.67988678 0.14552099 0.99288939 0.83194884 0.86382055
 0.56812589 0.90739427 0.59553776 0.51748574]

```

以上是100个随机数的结果，如果我们将它扩展为万，十万甚至更大，并使用python可视图，我们会发现这些点在某些地方没有覆盖，任留有大片空白，那么我们可以很清楚的从图像看出，冯诺依曼的这个迭代取中的方法来生成随机数不够理想。

python plotly+jupyter

### 线性同余生成器（LCG）

LCG，即线性同余生成器，一种`PRNG`，产生伪随机数的一种算法。

其数学递推式是：

> N(k+1) ≡ (A * N(k) + B )   ( mod M )

其中，`A、B、M`为随机数生成器确定值。

M>0 , 0<A<M , 0<= B <M , 0<=N(0)<M

当上述的递推式中B的值为0时，此时的线性同余生成器称为乘同余发生器，B>0时称为混合同余发生器。

从递推式可以看出，线性同余的递推式仅仅依赖于前一项，且随机序列只有M个可能取值，那么用该种方式产生的随机数序列必定会重复。

我们假定存在正整数`n、m（m<n）`，使得 `N(n) = N(m) `，那么就有 `N(n) + k == N(m) + k` ,那么，`N(n)、N(n+1)、N(n+2)……`与`N(m)、N(m+1)、N(m+2)……`会重复，我们将`n-m`的最小值取为`T`，`T`为该随机数发生器在初值 `N(0)`的周期。

`T <= M`，设想下假设递推公式为` N(k+1) ≡ (A * N(k) + B )   ( mod M )` ，若周期为`T`，则` N(k+T) =N(k)` , 由于` N(k+1) ≡ (A * N(k) + B )   ( mod M ) `也就是说唯一的 `N(k) `决定唯一的` N(k+1) `，那么`T`必小于等于`M`，因为取模`M`共有`M`个不同的整数结果，第`M+1`个数一定和前面某一个数相同，而由于一一对应的递推关系，后面的序列也会依次与前面的数相同，最后必有周期`T<=M`。

```python
from Crypto.Util.number import *
#基本LCG
class LCG():
    def __init__(self, n0=getRandomInteger(128)):
        self.a = getPrime(128)
        self.b = getPrime(128)
        self.m = getPrime(256)
        self.n = n0

    def next(self):
        self.n = (self.n * self.a + self.b) % self.m
        print(self.n)
        return self.n

lcg = LCG()
print (lcg.next())
print (lcg.next())
print (lcg.next())
```





#### 乘同余法

B=0，递推式为：

> N(k+1) ≡ A * N(k)    ( mod M )

我们应该选取合适的`M、A`，以达到满周期，且统计性质良好。首先是N(k) ！= 0 ，如果我们正在产生随机数时取到某个 `N(k)` 为`0`，则，`N(k+1) = N(k+2) = …… = 0`。则随机数直接进入`0`，并不发生周期变化，即退化情况。

通过一定的证明和推算，我们可以得出：`A`和`M`互素，且`M`与`N(0)`互素时，`N(n) = a^n * N(0)  ( mod M ) `，易得` N(k) `与` M` 互素，这样不会出现退化的情况。



对于上述，我在这里仅仅证明A与M互质，如下

> `N(k+1) ≡ A * N(k)    ( mod M )`
>
> 如果`A`与`M`不互质，那么我们可以令`A = a * d `，`M = m * d `
>
> 则上诉式子变为` N(k+1) = A * N(k) + k * M`
>
> (此处`B=0`，若`B`不为`0`，则将`B`当做一个偏移量，两边都减去`B`，即可)
>
> `N(k+1) =  d * (a * N(k) + k * m)`
>
> 以` d = 2 `为例，序列中原有的M个可能数字在循环中只能取到偶数值，也就是表明周期为`T <= M/2 `。
>
> 再列举一下，
>
> A=6，M=10，N(0)=2，序列为{2，2，2，……}，周期为1；
>
> A=3，M=5，N(0)=2，序列为{2，1，3，4，2，1，……}，周期为5；


#### 混合同余发生器

此处B>0，

>混合同余发生器可以达到满周期的条件
>
>1.B 与M互素；
>
>2.对于M的任一个素因子p，a-1 被p整除；
>
>3.如果 4 是 M 的因子，则 a − 1 被 4 整除；

一般而言，我们取 M=2^L，L 为计算机中整数的尾数字长。这时根据上述定理，建议取 a=4α+1, b=2β+1， α 和 β 为任意正整数，N(0) 为任意非负整数，这样的混合同余发生器是满周期的，周期为 2^L

关于同余法生成的随机变量序列的均匀分布状况以及其序列前后自相关系数的一些东西，可以详康[Random number](https://www.nkdacs.com/share/Random%20number/Random%20number/#32)、[统计计算](https://www.math.pku.edu.cn/teachers/lidf/docs/statcomp/html/_statcompbook/rng-uniform.html#rng-lcg-lcg)

```python
#random随机数生成（LCG）
import datetime
import math
import numpy as np
def _random():
    time=datetime.datetime.now()#时间戳
    a=np.arange(100)
    a0=str(time)[-6:] #取时间为随机数种子 存在安全漏洞，容易被预测v
    a0=int(a0)
    print("alpha=")
    alpha=int(input()) 
    print("beta=")
    beta=int(input()) 
    print("m=")
    m=int(input()) 
    a=4*alpha+1
    b=2*beta+1
    a=np.arange(100)
    for i in range(100):
        a1=(a*a0+b)%m
        a[i]=a1
        a0=a1
    print(a)
    a=a/a.max()
    print(a)
#输出
alpha=124
beta=1256
m=4523
[2642 3917 4372 4357 1425  627 2045 1203 3368 2899  479  857 3280 4393
 1225  733  451  510 2695 3120 1764 1759 3797 3531 2496 3723 2937 1273
 1974 2100 1400 1771  715  551  457 3492 1205 4362 3910  893 3080 4499
 4154   40 4301  731 3980 4022 2281  897  545 1998  459 4486 2216  253
 1610 2112 2841 3314 3199  320 3248 2058 3141 3155 1067 3621 1996 3988
 3475 1802 2553  391 2351 4026 4269 2919 1373 1921 2897 4008 4369 2866
 2170    6  972 1636 1465 2415 4173  437 2598  141  222 4295 2272  947
 2780  135  100  101  102  103  104  105  106  107  108  109  110  111
  112  113  114  115  116  117  118  119  120  121  122  123  124  125
  126  127  128  129  130  131  132  133  134  135  136  137  138  139
  140  141  142  143  144  145  146  147  148  149  150  151  152  153
  154  155  156  157  158  159  160  161  162  163  164  165  166  167
  168  169  170  171  172  173  174  175  176  177  178  179  180  181
  182  183  184  185  186  187  188  189  190  191  192  193  194  195
  196  197  198  199  200  201  202  203  204  205  206  207  208  209
  210  211  212  213  214  215  216  217  218  219  220  221  222  223
  224  225  226  227  228  229  230  231  232  233  234  235  236  237
  238  239  240  241  242  243  244  245  246  247  248  249  250  251
  252  253  254  255]
[0.58724161 0.87063792 0.9717715  0.96843743 0.31673705 0.1393643
 0.45454545 0.26739275 0.7486108  0.64436541 0.1064681  0.19048677
 0.7290509  0.97643921 0.27228273 0.16292509 0.1002445  0.11335852
 0.599022   0.69348744 0.39208713 0.39097577 0.84396533 0.78484108
 0.55478995 0.82751723 0.65281174 0.28295177 0.43876417 0.46677039
 0.31118026 0.39364303 0.15892421 0.12247166 0.10157813 0.77617248
 0.2678373  0.96954879 0.86908202 0.19848855 0.68459658 1.
 0.92331629 0.00889086 0.95599022 0.16248055 0.88464103 0.89397644
 0.50700156 0.19937764 0.12113803 0.44409869 0.10202267 0.99711047
 0.4925539  0.05623472 0.3578573  0.46943765 0.63147366 0.73660814
 0.7110469  0.07112692 0.72193821 0.45743499 0.69815515 0.70126695
 0.23716381 0.80484552 0.44365415 0.8864192  0.77239387 0.40053345
 0.56745944 0.0869082  0.52256057 0.89486553 0.94887753 0.64881085
 0.30517893 0.42698377 0.64392087 0.89086464 0.97110469 0.63703045
 0.48232941 0.00133363 0.21604801 0.36363636 0.32562792 0.53678595
 0.92753945 0.0971327  0.57746166 0.0313403  0.0493443  0.95465659
 0.50500111 0.21049122 0.61791509 0.03000667 0.02222716 0.02244943
 0.0226717  0.02289398 0.02311625 0.02333852 0.02356079 0.02378306
 0.02400533 0.02422761 0.02444988 0.02467215 0.02489442 0.02511669
 0.02533896 0.02556124 0.02578351 0.02600578 0.02622805 0.02645032
 0.02667259 0.02689487 0.02711714 0.02733941 0.02756168 0.02778395
 0.02800622 0.0282285  0.02845077 0.02867304 0.02889531 0.02911758
 0.02933985 0.02956212 0.0297844  0.03000667 0.03022894 0.03045121
 0.03067348 0.03089575 0.03111803 0.0313403  0.03156257 0.03178484
 0.03200711 0.03222938 0.03245166 0.03267393 0.0328962  0.03311847
 0.03334074 0.03356301 0.03378529 0.03400756 0.03422983 0.0344521
 0.03467437 0.03489664 0.03511892 0.03534119 0.03556346 0.03578573
 0.036008   0.03623027 0.03645255 0.03667482 0.03689709 0.03711936
 0.03734163 0.0375639  0.03778617 0.03800845 0.03823072 0.03845299
 0.03867526 0.03889753 0.0391198  0.03934208 0.03956435 0.03978662
 0.04000889 0.04023116 0.04045343 0.04067571 0.04089798 0.04112025
 0.04134252 0.04156479 0.04178706 0.04200934 0.04223161 0.04245388
 0.04267615 0.04289842 0.04312069 0.04334297 0.04356524 0.04378751
 0.04400978 0.04423205 0.04445432 0.04467659 0.04489887 0.04512114
 0.04534341 0.04556568 0.04578795 0.04601022 0.0462325  0.04645477
 0.04667704 0.04689931 0.04712158 0.04734385 0.04756613 0.0477884
 0.04801067 0.04823294 0.04845521 0.04867748 0.04889976 0.04912203
 0.0493443  0.04956657 0.04978884 0.05001111 0.05023339 0.05045566
 0.05067793 0.0509002  0.05112247 0.05134474 0.05156701 0.05178929
 0.05201156 0.05223383 0.0524561  0.05267837 0.05290064 0.05312292
 0.05334519 0.05356746 0.05378973 0.054012   0.05423427 0.05445655
 0.05467882 0.05490109 0.05512336 0.05534563 0.0555679  0.05579018
 0.05601245 0.05623472 0.05645699 0.05667926]
```

#### 素数模乘同余法

若M取小于2^L的最大素数，L 为计算机中整数的尾数字长。B=0，做乘同余法，我们可以选取合适的a使得周期T为满周期，我们可以得到近乎随机分布的乱序数，因为B=0，M取素数，我们把此时的线性同余生成器称为素数模乘同余法。

### 组合发生器

利用多个发生器，实现随机数生成器设计的独立性和多维分布性

例 Wichman 和 Hill(1982) 设计了如下的线性组合发生器，利用三个 16 位运算的素数模乘同余发生器:

作线性组合并求余：

> U(n) =171 * U(n−1)  ( mod 30269)
>
> V(n) =172 * V(n−1)  ( mod 30307)
>
> W(n) =170 * W(n−1)  ( mod 30323)

作线性组合并求余：

>Rn = ( U(n) / 30269 + V(n) / 30307 + W(n) / 30323 )   ( mod 1 )

这个组合发生器的周期约有 7×1012 长, 超过 232≈4×109。

例：MacLaren 和 Marsaglia(1965) 设计了组合同余法，组合两个同余发生器，一个用来 “搅乱” 次序。

设有两个同余发生器 A 和 B。用 A 产生 m 个随机数 (如 m=128)，存放在数组T=(t1,t2,...,tm)。 需要产生 xn 时，从 B 中生成一个随机下标 j∈{1,2,...,m}，取 xn=tj ，但从 A 再生成一个新随机数 y 代替 T 中的 tj，如此重复。这样组合可以增强随机性，加大周期 (可超过 2L )。也可以只使用一个发生器，用 xn−1 来选择下标。

```python
#random随机数生成（组合发生器）
import datetime
import math
import numpy as np

time=datetime.datetime.now()#时间戳
x=np.arange(100)
a0=str(time)[-3:] #取时间为随机数种子 存在安全漏洞，容易被预测v
a0=int(a0)
print("alpha=")
alpha=int(input()) 
print("beta=")
beta=int(input()) 
print("m=")
m=int(input()) 
a=4*alpha+1
b=2*beta+1
for i in range(100):
    a1=(a*a0+b)%m
    x[i]=a1
    a0=a1
b0=str(time)[-6:-3]
b0=int(b0)
y=np.arange(100)
for j in range(100):
    b1=(a*b0+b)%m
    y[i]=x[b1]
    x[b1]=(a*a0)%m
    b0=b1
    a0=x[b1]
print(y)
y=y/y.max()
print(y)

#输出
alpha=4
beta=5
m=3
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71
 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
 96 97 98  0]
[0.         0.01020408 0.02040816 0.03061224 0.04081633 0.05102041
 0.06122449 0.07142857 0.08163265 0.09183673 0.10204082 0.1122449
 0.12244898 0.13265306 0.14285714 0.15306122 0.16326531 0.17346939
 0.18367347 0.19387755 0.20408163 0.21428571 0.2244898  0.23469388
 0.24489796 0.25510204 0.26530612 0.2755102  0.28571429 0.29591837
 0.30612245 0.31632653 0.32653061 0.33673469 0.34693878 0.35714286
 0.36734694 0.37755102 0.3877551  0.39795918 0.40816327 0.41836735
 0.42857143 0.43877551 0.44897959 0.45918367 0.46938776 0.47959184
 0.48979592 0.5        0.51020408 0.52040816 0.53061224 0.54081633
 0.55102041 0.56122449 0.57142857 0.58163265 0.59183673 0.60204082
 0.6122449  0.62244898 0.63265306 0.64285714 0.65306122 0.66326531
 0.67346939 0.68367347 0.69387755 0.70408163 0.71428571 0.7244898
 0.73469388 0.74489796 0.75510204 0.76530612 0.7755102  0.78571429
 0.79591837 0.80612245 0.81632653 0.82653061 0.83673469 0.84693878
 0.85714286 0.86734694 0.87755102 0.8877551  0.89795918 0.90816327
 0.91836735 0.92857143 0.93877551 0.94897959 0.95918367 0.96938776
 0.97959184 0.98979592 1.         0.        ]
```

上述算法存在一个问题，第二个发生器所产生的b1应在第一个发生器产生的随机数池中（我们假定随机数池中有n个数，则b1<=n），也就是说所选取的a，b，m与seed之间存在较大限制

### 梅森旋转算法

C++11起、R、Python、Ruby、IDL、Free Pascal、PHP、Maple、Matlab、GNU 多重精度运算库和 GSL 的默认伪随机数产生器基本都是用梅森旋转算法。

MT19937[https://liam.page/2018/01/12/Mersenne-twister/]

 **MT19937-32的参数列表如下： **
>
>  (w, n, m, r) = (32, 624, 397, 31)  
>
>  a = 0x9908B0DF   
>
>  f = 1812433253    
>
>  (u, d) = (11, 0xFFFFFFFF)    
>
>  (s, b) = (7, 0x9D2C5680)    
>
>  (t, c) = (15, 0xEFC60000)    
>
>  l = 18 


 **MT19937-64的参数列表如下：  **
>
> (w, n, m, r) = (64, 312, 156, 31)    
>
> a = 0xB5026F5AA96619E9    
> f = 6364136223846793005    
>
> (u, d) = (29, 0x5555555555555555)    
>
> (s, b) = (17, 0x71D67FFFEDA60000)    
>
> (t, c) = (37, 0xFFF7EEE000000000)    
>
> l = 43

**梅森旋转算法**

> 第一阶段：初始化，获得基础的梅森旋转链；
> 第二阶段：对于旋转链进行旋转算法；
> 第三阶段：对于旋转算法所得的结果进行处理；


**初始化**
>
> 首先将传入的seed赋给MT[0]作为初值，然后根据递推式：MT[i] = f × (MT[i-1] ⊕ (MT[i-1] >> (w-2))) + i递推求出梅森旋转链。


 **对旋转链执行旋转算法**
>
> 遍历旋转链，对每个MT[i]，根据递推式：MT[i] = MT[i+m]⊕((upper_mask(MT[i]) || lower_mask(MT[i+1]))A）进行旋转链处理。


**对旋转算法所得结果进行处理**
>
>设x是当前序列的下一个值，y是一个临时中间变量，z是算法的返回值。则处理过程如下：
>y := x ⊕ ((x >> u) & d)
>y := y ⊕ ((y << s) & b)
>y := y ⊕ ((y << t) & c)
>z := y ⊕ (y >> l)


```python
# MT19937
def _int32(x):
    return int(0xFFFFFFFF & x)

class MersenneTwister_19937:
    def _int32(x):
        return int(0xFFFFFFFF & x)

    def __init__(self, seed=0):
        self.mt = [0] * 624
        self.mt[0] = seed
        for i in range(1, 624):
            self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] >> 30) + i) #f = 1812433253  


    def extract_number(self):
        self.twist()
        y = self.mt[0]
        y = y ^ y >> 11 #u
        y = y ^ y << 7 & 2636928640 #(s,b)
        y = y ^ y << 15 & 4022730752 #(t,c)
        y = y ^ y >> 18 #l
        return _int32(y)


    def twist(self):
        for i in range(0, 624):
            y = _int32((self.mt[i] & 0x80000000) + (self.mt[(i + 1) % 624] & 0x7fffffff)) #upper_mask=0x80000000 lower_mask=0x7fffffff
            self.mt[i] = y ^ self.mt[(i + 397) % 624] >> 1

            if y % 2 != 0:
                self.mt[i] = self.mt[i] ^ 0x9908b0df #a=0x9908b0df
    
    def __call__(self):
        return self.extract_number()
               

if __name__ == "__main__":
    mt = MersenneTwister_19937(0)
    tank = set()
    kLen = 100
    for i in range(kLen):
        t = mt()
        tank.add(t)
        print(t)
    print(len(tank) == kLen)

#输出seed=0时
3555566542
2277476804
355685
3772589102
1974161505
3692270947
2145027938
373691124
2941439657
2661620223
1941504926
2489317217
880354109
1843412307
44519857
3541762794
1579642343
3903046643
2351977652
4050010944
4272419775
1410772155
1809908775
1392220299
732861692
1586892464
264608727
1452509909
2403296127
2361065430
1774012356
690824437
2548882410
2806923508
3978474371
83375422
1766387144
2668455533
3807242720
220331857
1670067441
589134873
600932241
2567923789
1431039982
630820461
2919335382
1217623415
1699432777
3199871450
2701329837
1526450808
1269650527
4039233436
1861176638
1741115615
879572815
437598363
3205123436
554854416
408277470
2706077452
3468939297
2076361524
2751985530
1266996792
3198254308
902472400
3015221229
361918507
339057653
1126341685
2112437773
2789121564
1612122202
1920640716
3724116709
2405956278
652677954
2890260294
4290200916
3165481070
322044506
1138540597
2115360783
1598024077
88493704
1069980940
4125532964
2768917773
4283742562
4228615909
4032227666
1819570879
2295729209
2098174225
987982849
1935355293
158481919
1504885396
True

```


```python

#MT19937-64
def _int64(x):
    return int(0x5555555555555555 & x)

class MT19937_64:
    def __init__(self, seed):
        self.mt = [0] * 312
        self.mt[0] = seed
        for i in range(1, 312):
            self.mt[i] = _int64(6364136223846793005  * (self.mt[i - 1] ^ self.mt[i - 1] >> 30) + i) 


    def extract_number(self):
        self.twist()
        y = self.mt[0]
        y = y ^ y >> 29 #u
        y = y ^ y << 17 & 0x71D67FFFEDA60000 #(s,b)
        y = y ^ y << 37 & 0xFFF7EEE000000000 #(t,c)
        y = y ^ y >> 43 #l
        return _int64(y)


    def twist(self):
        for i in range(0, 312):
            y = _int64((self.mt[i] & 0x80000000) + (self.mt[(i + 1) % 312] & 0x7fffffff)) #upper_mask=0x80000000 lower_mask=0x7fffffff
            self.mt[i] = y ^ self.mt[(i + 156) % 312] >> 1

            if y % 2 != 0:
                self.mt[i] = self.mt[i] ^ 0xB5026F5AA96619E9 #a=0x9908b0df

    def __call__(self):
        return self.extract_number()

if __name__ == "__main__":
    mt = MT19937_64(0)
    tank = set()
    kLen = 100
    for i in range(kLen):
        t = mt()
        tank.add(t)
        print(t)
    print(len(tank) == kLen)

#输出 seed=0
72409512186758416
1153225250402796608
1447137713395618885
6057711295838557457
1447067275931947265
289730390548041989
1518013520544010497
6126307283333879040
6076782256319448132
4702977648882680085
4579759414661460
1514691617611859221
1196341950939157
76931815340774672
23715440404467728
76579134013178176
1154400708545824001
5787214930580078676
23662950539857924
1535798941189162308
4900286128269365329
4900269629957489668
383158933102330881
5859200987709838676
1243298131689423872
1170935977276145985
1225261763617969153
4684101320179778901
306245947188646917
5718840495637573
312244831429858389
5859188893282222161
1244212878434910480
5842577557577352513
1513562505007595521
1535727835121190160
4990076713145794832
73487235110995221
4707387786733638720
1535749742339048516
6000036383097092
365918591873532944
1154417133825904900
306320990270735425
5787496401344922709
4703240518073651269
4904491549453260116
288252658728304657
1154351970312537153
1226475809993462800
311874567684490580
289361017786668053
379451428495705349
6148561674921330001
1229571025437725717
5841240276224771333
1514688678713361473
4901042315983065104
4611973008427648340
1537206659674341713
1514339795387876612
4635331309118751056
1496453868765521
6072259695400518976
4634490989099357265
5842577466040012805
76913334007447621
1536026631381009680
1219706308857873
1513232909481558101
23929856970790160
310836422276895056
5783840546640368976
4707405171699815765
4631178522702200896
1441508127915659281
1230965137642443024
4904701835598975312
1229488283093898576
1442630798074446928
5764612007315902529
4972044358452053252
1248698880439095573
306244844794499392
4905903258227197265
6052909642660726096
1153009757599125568
23714627633545280
6058490493854089537
6148896754042422545
1247867632288354624
311893331033740368
4971975433152188672
18313466013287700
4629704906537714704
4977978490609550661
5842646533431103569
1230966300252128576
4689672523854648340
6054056507107267861
True

```



多数编译器中的库是使用了LCG来实现产生伪随机数发生器的函数，如glibc和ANSI中的rand()函数。如下是其中rand()函数使用的参数值

![image-20201124151141048](file://C:/Users/MECHREVO/AppData/Roaming/Typora/typora-user-images/image-20201124151141048.png?lastModify=1606227069)

rand()函数的种子s(0)是固定的，因此每次调用该函数时，其产生的随机数数列都是相同的。



（https://www.nkdacs.com/share/Random%20number/Random%20number/）

Linux下/dev/random 是一个阻塞数字生成器，如果它没有足够的随机数据提供，它就一直等，这迫使 JVM 等待。键盘和鼠标输入以及磁盘活动可以产生所需的随机性或熵。但在一个缺乏这样的活动服务器，可能会出现问题，当系统的熵池中数量不足时，就会阻塞当前线程。（https://www.cnblogs.com/xiekun/p/11938196.html）



## PRNG攻击

### LCG攻击

> N(k+1) ≡ (A * N(k) + B )   ( mod M )

<u>1.全部已知<u>

已知内部参数，且只要随便一个输出，即可推测出未来甚至过去的随机序列。

假使我们知道 任意N(k)，则之后的输出为

> N(k+1) ≡ (A * N(k) + B )   ( mod M )

之前的输出为

> N(k-1) ≡ A ^ (-1) * ( N(k) - B )   ( mod M )

```python
A ^ (-1)=gmpy2.invert(A,M)

#A、B、M、N(k)已知
a =
b = 
m = 
s2 =
s3 = (s2 * a + b) % m
s1 = ((s2 - b) * gmpy2.invert(a, m)) % m
```

<u>2.仅B未知<u>

已知内部参数，乘数A、模数M、，知道**连续**两个输出

> B = (N(k+1) - A * N(k))  mod  M

```python
a = 
m = 
s1 = 
s2 = 
b = (s2 - s1 * a) % m
```

<u>3.A、B未知<u>

已知内部参数模数M，但不知道乘数A和增量B，但知道**连续**三个输出

我们就可以通过方程推算出A、B

>N(k+1) = (N(k) * A + B) mod M
>
>N(k+2) = (N(k+1) * A + B) mod M

>N(k+2) - N(k+1) = A * ( N(k+1) - N(k) )mod M
>
>A = ( N(k+1) - N(k) )^(-1) * ( N(k+2) - N(k+1) ) mod M

```python
m = 
s1 = 
s2 = 
s3 = 
a = (gmpy2.invert((s2 - s1), n) * (s3 - s2)) % m
b = (s2 - s1 * a) % m
```

这里要求计算 `N(k+1) - N(k)` 在模M下的逆元，因此两者互素，若不互素，则n 就除以从 2 开始的素数，直到可以整除，然后再判断`N(k+1) - N(k)`与M 是否互素。

```python
from Crypto.Util.number import sieve_base

def check_n(s, n):
    for i in range(len(s)-1):
        if gmpy2.gcd(s[i+1] - s[i], n) != 1:
            return False
    return True

while not check_n(s, n):
    for i in sieve_base:
        if n % i == 0:
            n = n // i
            print(i)
            break
```

以上是通过方程形式求解

另外地还有一种基于格的求解方式（通法）

基于LLL（此算法十分的十分的有用~），对于构造的格基进行约化.

>N(1) = (N(0) * A + B) mod M
>
>N(2) = (N(1) * A + B) mod M

详细可以参考：https://0xdktb.top/2020/03/27/Summary-of-Crypto-in-CTF-PRNG/

```python
A = Matrix([
    [s0  ,s1  ,1/m ,0   ,0   ],
    [1   ,1   ,0   ,1/m ,0   ],
    [-s1 ,-s2 ,0   ,0   ,1   ],
    [m   ,0   ,0   ,0   ,0   ],
    [0   ,m   ,0   ,0   ,0   ]
])
A = A.LLL()
a = None
b = None
for l in A:
    if l[0] == 0 and l[1] == 0:
        if l[-1] == 1:
            a, b = l[2] * m, l[3] * m
        elif l[-1] == -1:
            a, b = -l[2] * m, -l[3] * m
        else:
            continue
if not a or not b:
    raise ValueError("[*] No solves")
a %= m
b %= m
```



<u>4.全部未知<u>

内部参数全都未知，但我们知道若干输出，可推算出A、B、M

>令 X(k) = N(k) - N(k-1)
>
>X(k)  = N(k) - N(k-1) 
>
>​         = (N(k-1) * A + B) mod M - (N(k-2) * A + B) mod M 
>
>​         = A * ( N(k-1)  - N(k-2) ) mod M
>
>​         = A * X(k-1) mod M

>X(k+2) * X(k) - X(k+1)^2 = A^2 * X(k)^2 - A^2 * X(k)^2 mod M = 0 mod M

即：

>X(3) * X(1) - X(2)^2 = k1 * M
>
>X(4) * X(2) - X(3)^2 = k2 * M

```python
s = [s1, s2, s3, s4, s5, s6,]
x = [s[i] - s[i-1] for i in range(1, len(s))]
t = [(x[i-2] * x[i] - x[i-1] * x[i-1]) for i in range(2, len(s)-2)]
print (reduce(gmpy2.gcd, t))
```

```python
from Crypto.Util.number import *

# LCG生成器
class LCG:
    def __init__(self):
        m = getPrime(256)
        a = getRandomRange(2, m)
        b = getRandomRange(2, m)
        seed = getRandomRange(2, m)
        self._key = {'a':a, 'b':b, 'm':m}
        self._state = seed
        
    def next(self):
        self._state = (self._key['a'] * self._state + self._key['b']) % self._key['m']
        return self._state
    
    def export_key(self):
        return self._key
    
#攻击LCG，预测
data = []
for i in range(6):
    data.append(prng.next())
from functools import reduce
delta = [d1 - d0 for (d0, d1) in zip(data, data[1:])]
m_mul = [d0 * d2 - d1 * d1 for (d0, d1, d2) in zip(delta, delta[1:], delta[2:])]
m = reduce(GCD, m_mul)
factors = factor(m)
if len(factors) > 1:
    for (prime, degree) in factors:
        if size(prime) == 256:
            m = prime
            break
        m //= (prime**degree)
print(m)
#转为A、B未知的情况
```

<u>5.Truncated LCG<u>

参考：https://github.com/arxenix/Truncated-LCG-Cracking

视情况再写吧，主要是我还不太明白，嘤嘤嘤~

### MT 预测

python下Randcrack库的RandCrack可以直接攻击

预测python的“random”模块随机生成的值

cracker 不实现`random（）`函数的预测，因为它基于基于`/dev/urandom`的`os.urandom`模块

```python
from randcrack import RandCrack

Rand = RandCrack()
with open('random', 'r') as f:
    data = [int(line.rstrip('\n')) for line in f]
assert(len(data) >= 624)
for i in range(624):
    Rand.submit(data[i])
for i in range(624, len(data)):
    Rand.predict_randrange(0, 0xffffffff)
print Rand.predict_randrange(0, 0xffffffff)
```









```python
a=(0xffffffff << (32 - shift)) 二进制罩 1110 0000
& 1100 1000  &result
1100 0000   最高shift位已知了
>> shift  = 0001 1000  
^ 1100 1000  ^result
1101 0000   最高shift*2位已知
a=(0xffffffff << (32 - shift*2))
& 1100 1000 &result


```











异或等位运算的逆向

以向右移位后异或为例

```python
def right_shift_xor(value,shift):
    result = value
    result ^= (result >> shift)
    return result
value : 明文
shift : 右移（或者左移）的位数
result : 密文
```

简单地，我们以一个8位二进制数为例，将它右移3位后异或

```
value:    1101 0010
shifted:  0001 1010 # 010 (>> 3)
result:   1100 1000
```

我们可以看到value的最高shift位，与result的最高shift位是一样的，我们可以通过将result与一个二进制遮罩取与，得到result的最高shift位，即value的最高shift位。这个遮罩应该是：`1111 1111 << (8 - shift) = 1110 0000(这里shift == 3)`。 将改遮罩和result取与，我们可以得到 `1100 0000` 。则我们得到的就是value的最高shift位。

由于异或运算存在如下事实：`a ^ b ^ b  = a`。

如上，我们得到了value的最高shift位，即result的最高shift位，即 `shifted ` 的 ` shift + 1 `到 `shift * 2 `位，现在我们需要复原value的shift+1到shift * 2位。我们知道了 `shifted ` 的 ` shift + 1 `到 `shift * 2 `位，并且我们有result的 ` shift + 1 `到 `shift * 2 `位，由`a ^ b ^ b  = a`，我们只要将上诉拿到的 `1100 0000` 右移shift位，再将其与result取异或，即可拿到value的最高shift * 2 位。于是我们得到`1101 0000`。

```python
(0xffffffff << (32 - shift)) 二进制遮罩 1110 0000
& 1100 1000  &result
1100 0000   最高shift位已知了
>> shift  = 0001 1000  复原了shifted 的前shift * 2位
^ 1100 1000  ^result
1101 0000   最高shift*2位已知
a=(0xffffffff << (32 - shift)) 二进制遮罩 1110 0000
& 1101 0000 &result 此时result = 1101 0000
1100 0000 
>> shift * 2  = 0000 0011
^ 1101 0000
1101 0011


```

```python
def inverse_right_shift_xor(value, shift):
    i, result = 0, 0
    while i * shift < 8:
        part_mask = ((0xffffffff << (8 - shift)) & 0xffffffff) >> (i * shift)
        part = value & part_mask
        value ^= part >> shift
        result |= part
        i += 1
    return result
    i=0
    value=1100 1000
    0 * 3 <8
    part_mark = 1110 0000 & 1111 1111 >> (0 * 3)= 1110 0000
    part = 1100 1000 & 1110 0000 =1100 0000
    value = 1100 1000 ^ (1100 0000 >> 3) =1100 1000 ^ 0001 1000=1101 0000
    result= 0000 0000 | 1100 0000 = 1100 0000 
    i=1
    value=1101 0000 
    1 * 3 <8
    part_mark = 1110 0000 >> (1 * 3) = 0001 1100
    part =1101 0000 & 0001 1100 = 1100 1100
    value = 1101 0000 ^ (1100 1100 >> 3) = 1101 0000 ^ 0001 1001 = 1100 1001
    result = 1100 0000 | 1100 1100 = 1100 1100
    i=2
    value = 1100 1001
    2 * 3 <8
      part_mark = 1110 0000 >> (2 * 3) = 0000 0011
    part = 1100 1001 & 0000 0011 = 0000 0001
    value = 1100 1001 ^ (0000 0001 >> 3) = 1100 1001
    result = 1100 1100 | 0000 0001 = 1100 1101
    i=3
    
    
    
```

 











